<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Designer Clothing Store</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #fff;
        }
        canvas {
            display: block;
            width: 100vw !important;
            height: 100vh !important;
        }
        @media (max-width: 768px) {
            canvas {
                width: 100vw !important;
                height: 100vh !important;
            }
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // OrbitControls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 2;
        controls.maxDistance = 10;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(0, 1, 2);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const spotlight1 = new THREE.SpotLight(0xffffff, 2);
        spotlight1.position.set(0, 5, 4);
        spotlight1.angle = Math.PI / 6;
        spotlight1.penumbra = 0.5;
        spotlight1.castShadow = true;
        spotlight1.target.position.set(0, 0, 4);
        scene.add(spotlight1);
        scene.add(spotlight1.target);

        // Floor with polished wood texture
        const textureLoader = new THREE.TextureLoader();
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b5e3c, // Warm wood tone
            roughness: 0.4,
            metalness: 0.1
            // Suggested texture: https://cc0textures.com/view?id=WoodFlooring008
        });
        const floorGeometry = new THREE.PlaneGeometry(10, 10);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // White walls
        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.5,
            metalness: 0
        });
        const wall1 = new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial);
        wall1.position.set(0, 2.5, -5);
        scene.add(wall1);
        const wall2 = new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial);
        wall2.position.set(-5, 2.5, 0);
        wall2.rotation.y = Math.PI / 2;
        scene.add(wall2);
        const wall3 = new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial);
        wall3.position.set(0, 2.5, 5);
        scene.add(wall3);

        // Register (replacing desk)
        const registerGeometry = new THREE.BoxGeometry(3, 1, 1);
        const registerMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.3,
            metalness: 0.1
            // Suggested texture: https://cc0textures.com/view?id=Wood009
        });
        const register = new THREE.Mesh(registerGeometry, registerMaterial);
        register.position.set(0, 0.5, 4);
        register.castShadow = true;
        scene.add(register);

        // Register top (glass-like surface)
        const registerTopGeometry = new THREE.BoxGeometry(3, 0.05, 1);
        const registerTopMaterial = new THREE.MeshStandardMaterial({
            color: 0xcccccc,
            roughness: 0.1,
            metalness: 0.8,
            transparent: true,
            opacity: 0.9
        });
        const registerTop = new THREE.Mesh(registerTopGeometry, registerTopMaterial);
        registerTop.position.set(0, 1.025, 4);
        scene.add(registerTop);

        // Clothing shelves along walls
        const shelfMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b5e3c, // Matching wood tone
            roughness: 0.4,
            metalness: 0.1
        });
        const shelfGeometry = new THREE.BoxGeometry(4, 0.1, 0.5);
        const shelves = [
            { pos: [-2.5, 1, -4.75], rot: 0 },
            { pos: [-2.5, 2, -4.75], rot: 0 },
            { pos: [2.5, 1, -4.75], rot: 0 },
            { pos: [2.5, 2, -4.75], rot: 0 },
            { pos: [-4.75, 1, -2], rot: Math.PI / 2 },
            { pos: [-4.75, 2, -2], rot: Math.PI / 2 },
            { pos: [4.75, 1, 2], rot: -Math.PI / 2 },
            { pos: [4.75, 2, 2], rot: -Math.PI / 2 }
        ];
        shelves.forEach(s => {
            const shelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
            shelf.position.set(...s.pos);
            shelf.rotation.y = s.rot;
            shelf.castShadow = true;
            scene.add(shelf);
        });

        // Clothing racks with hangers
        const rackMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.3,
            metalness: 0.7
        });
        const rackGeometry = new THREE.BoxGeometry(3, 0.05, 0.05);
        const rackSupportGeometry = new THREE.BoxGeometry(0.05, 1.5, 0.05);
        const racks = [
            { pos: [0, 1.5, 0] },
            { pos: [0, 1.5, 2] }
        ];
        racks.forEach(r => {
            const rack = new THREE.Mesh(rackGeometry, rackMaterial);
            rack.position.set(r.pos[0], r.pos[1], r.pos[2]);
            rack.castShadow = true;
            scene.add(rack);
            const support1 = new THREE.Mesh(rackSupportGeometry, rackMaterial);
            support1.position.set(r.pos[0] - 1.5, r.pos[1] - 0.75, r.pos[2]);
            scene.add(support1);
            const support2 = new THREE.Mesh(rackSupportGeometry, rackMaterial);
            support2.position.set(r.pos[0] + 1.5, r.pos[1] - 0.75, r.pos[2]);
            scene.add(support2);
        });

        // Hangers on racks
        const hangerGeometry = new THREE.TorusGeometry(0.1, 0.01, 8, 3, Math.PI);
        const hangerMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.5,
            metalness: 0.5
        });
        racks.forEach(r => {
            for (let x = -1.2; x <= 1.2; x += 0.3) {
                const hanger = new THREE.Mesh(hangerGeometry, hangerMaterial);
                hanger.position.set(r.pos[0] + x, r.pos[1] - 0.1, r.pos[2]);
                hanger.rotation.x = Math.PI / 2;
                scene.add(hanger);
            }
        });

        // 3D Clothing Meshes
        const clothingMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333, // Dark fabric tone
            roughness: 0.7,
            metalness: 0
            // Suggested texture: https://cc0textures.com/view?id=Fabric042
        });
        const shirtGeometry = new THREE.BoxGeometry(0.2, 0.3, 0.05); // Simplified shirt
        const jacketGeometry = new THREE.BoxGeometry(0.25, 0.4, 0.06); // Simplified jacket
        // Shirts on shelves
        shelves.forEach(s => {
            for (let i = -1.5; i <= 1.5; i += 0.5) {
                const shirt = new THREE.Mesh(shirtGeometry, clothingMaterial);
                shirt.position.set(s.pos[0] + (s.rot === 0 ? i : 0), s.pos[1] + 0.1, s.pos[2] + (s.rot !== 0 ? i : 0));
                shirt.rotation.y = s.rot;
                scene.add(shirt);
            }
        });
        // Jackets on hangers
        racks.forEach(r => {
            for (let x = -1.2; x <= 1.2; x += 0.3) {
                const jacket = new THREE.Mesh(jacketGeometry, clothingMaterial);
                jacket.position.set(r.pos[0] + x, r.pos[1] - 0.3, r.pos[2]);
                scene.add(jacket);
            }
        });

        // Store sign
        const signCanvas = document.createElement('canvas');
        signCanvas.width = 1024;
        signCanvas.height = 256;
        const signContext = signCanvas.getContext('2d');
        signContext.fillStyle = '#ffffff';
        signContext.fillRect(0, 0, signCanvas.width, signCanvas.height);
        signContext.font = '200px Arial';
        signContext.fillStyle = '#333333';
        signContext.textAlign = 'center';
        signContext.textBaseline = 'middle';
        signContext.fillText('ModeVibe', signCanvas.width / 2, signCanvas.height / 2);
        const signTexture = new THREE.CanvasTexture(signCanvas);
        const neonSignGeometry = new THREE.PlaneGeometry(3, 0.75);
        const neonSignMaterial = new THREE.MeshBasicMaterial({
            map: signTexture,
            transparent: true
        });
        const neonSign = new THREE.Mesh(neonSignGeometry, neonSignMaterial);
        neonSign.position.set(0, 3, -4.9);
        scene.add(neonSign);

        // Camera position
        camera.position.set(4, 2, -3);
        camera.lookAt(0, 1, 2);

        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
