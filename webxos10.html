<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>webXOS Studio</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        canvas {
            display: block;
            width: 100vw !important;
            height: 100vh !important;
            touch-action: none;
        }
        .sidebar {
            position: fixed;
            top: 0;
            left: -200px;
            width: 200px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            z-index: 10;
            transition: left 0.3s ease;
        }
        .sidebar.open {
            left: 0;
        }
        .sidebar h1 {
            font-size: 1.8rem;
            color: #00ff00;
            margin-bottom: 15px;
            margin-top: 50px;
        }
        .sidebar ul {
            list-style: none;
        }
        .sidebar li {
            margin: 10px 0;
        }
        .sidebar a {
            color: #aaa6c3;
            text-decoration: none;
            font-size: 1.1rem;
            display: block;
            padding: 10px;
            border-radius: 5px;
        }
        .sidebar a:hover {
            background: #00ff00;
            color: #000000;
        }
        .menu-toggle {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 10px;
            background: #00ff00;
            color: #000000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 11;
            font-size: 1rem;
            touch-action: manipulation;
        }
        .text-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            color: #ffffff;
            font-size: 1rem;
            z-index: 10;
            max-width: 80%;
        }
        .center-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff00;
            border-radius: 5px;
            color: #00ff00;
            font-size: 1.5rem;
            text-align: center;
            z-index: 10;
            max-height: 80vh;
            overflow-y: auto;
        }
        @media (max-width: 768px) {
            .sidebar {
                width: 160px;
                left: -160px;
            }
            .sidebar h1 {
                font-size: 1.4rem;
                margin-top: 40px;
            }
            .sidebar a {
                font-size: 1rem;
                padding: 8px;
            }
            .menu-toggle {
                padding: 8px;
                font-size: 0.9rem;
            }
            .text-overlay {
                font-size: 0.9rem;
                padding: 8px;
                bottom: 15px;
                left: 15px;
                max-width: 90%;
            }
            .center-overlay {
                font-size: 1.2rem;
                padding: 10px;
                max-width: 90%;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <button class="menu-toggle" onclick="toggleMenu()">â˜° Menu</button>
    <div class="sidebar" id="sidebar">
        <h1>webXOS Studio</h1>
        <ul>
            <li><a href="#" onclick="navigateTo('about')">About</a></li>
            <li><a href="#" onclick="navigateTo('tools')">Tools</a></li>
            <li><a href="#" onclick="navigateTo('aiAgents')">AI Agents</a></li>
            <li><a href="#" onclick="navigateTo('games')">Games</a></li>
            <li><a href="#" onclick="navigateTo('copyright')">Copyright</a></li>
        </ul>
    </div>
    <div class="text-overlay" id="textOverlay"></div>
    <div class="center-overlay" id="centerOverlay"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
        const camera = new THREE.PerspectiveCamera(isMobile ? 70 : 60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: !isMobile });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setAnimationLoop(animate);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x00ff00, 0.4);
        scene.add(ambientLight);
        const naturalAmbientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(naturalAmbientLight);
        const spotlight1 = new THREE.SpotLight(0x00ff00, 2);
        spotlight1.position.set(0, 5, 4);
        spotlight1.angle = Math.PI / 6;
        spotlight1.penumbra = 0.5;
        spotlight1.castShadow = true;
        spotlight1.target.position.set(0, 0, 4);
        scene.add(spotlight1);
        scene.add(spotlight1.target);

        // Base wall neon lights
        const baseLightPositions = [
            [-4, 0.1, -4.5], [0, 0.1, -4.5], [4, 0.1, -4.5],
            [-4, 0.1, 4.5], [0, 0.1, 4.5], [4, 0.1, 4.5],
            [-4.5, 0.1, -2], [-4.5, 0.1, 2],
            [4.5, 0.1, -2], [4.5, 0.1, 2]
        ];
        baseLightPositions.forEach(pos => {
            const pointLight = new THREE.PointLight(0x00ff00, 1, 3);
            pointLight.position.set(...pos);
            scene.add(pointLight);
            const lightGlow = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 })
            );
            lightGlow.position.set(...pos);
            scene.add(lightGlow);
        });

        // Neural network ceiling effect (optimized for mobile)
        const neuralMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 2,
            transparent: true,
            opacity: 0.9
        });
        const neuralNodeGeometry = new THREE.SphereGeometry(0.03, 8, 8);
        const neuralLineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
        const nodes = [];
        const numNodes = isMobile ? 30 : 50;
        for (let i = 0; i < numNodes; i++) {
            const node = new THREE.Mesh(neuralNodeGeometry, neuralMaterial);
            node.position.set(Math.random() * 8 - 4, 4.8, Math.random() * 8 - 4);
            scene.add(node);
            nodes.push(node.position);
        }
        const neuralLinesGeometry = new THREE.BufferGeometry();
        const lineVertices = [];
        for (let i = 0; i < numNodes; i++) {
            for (let j = i + 1; j < numNodes; j++) {
                if (Math.random() < (isMobile ? 0.05 : 0.1)) {
                    lineVertices.push(nodes[i].x, nodes[i].y, nodes[i].z);
                    lineVertices.push(nodes[j].x, nodes[j].y, nodes[j].z);
                }
            }
        }
        neuralLinesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(lineVertices, 3));
        const neuralLines = new THREE.LineSegments(neuralLinesGeometry, neuralLineMaterial);
        scene.add(neuralLines);

        const ceilingLight = new THREE.PointLight(0x00ff00, 1.5, 10);
        ceilingLight.position.set(0, 4.8, 0);
        scene.add(ceilingLight);

        // Floor
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x1c1c1c,
            roughness: 0.7,
            metalness: 0.5
        });
        const floorGeometry = new THREE.PlaneGeometry(10, 10);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Walls
        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000,
            roughness: 0.8,
            metalness: 0.2
        });
        const wall1 = new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial);
        wall1.position.set(0, 2.5, -5);
        scene.add(wall1);
        const wall2 = new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial);
        wall2.position.set(-5, 2.5, 0);
        wall2.rotation.y = Math.PI / 2;
        scene.add(wall2);
        const wall3 = new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMaterial);
        wall3.position.set(0, 2.5, 5);
        scene.add(wall3);

        // Desk - Glass top
        const deskGeometry = new THREE.BoxGeometry(8, 0.8, 4);
        const deskMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.2,
            roughness: 0.1,
            metalness: 0.9
        });
        const desk = new THREE.Mesh(deskGeometry, deskMaterial);
        desk.position.set(0, 0.4, 3);
        desk.rotation.y = Math.PI;
        desk.receiveShadow = true;
        desk.castShadow = true;
        scene.add(desk);

        // Neon glow to desk top edge
        const deskEdgeGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(8, 0.01, 4));
        const deskEdgeMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3 });
        const deskEdge = new THREE.LineSegments(deskEdgeGeometry, deskEdgeMaterial);
        deskEdge.position.set(0, 0.795, 3);
        deskEdge.rotation.y = Math.PI;
        deskEdge.position.z = 6 - (deskEdge.position.z - 3);
        scene.add(deskEdge);

        // Common material for desk items
        const itemMaterial = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.3,
            metalness: 0.7
        });

        // Matrix-style scrolling text for monitors
        const canvasTextures = [];
        const canvasElements = [];
        for (let i = 0; i < 3; i++) {
            const canvas = document.createElement('canvas');
            canvas.width = isMobile ? 256 : 512;
            canvas.height = isMobile ? 256 : 512;
            const context = canvas.getContext('2d');
            canvasElements.push({ canvas, context, drops: Array(Math.floor(canvas.width / (isMobile ? 10 : 20))).fill(0) });
            const texture = new THREE.CanvasTexture(canvas);
            canvasTextures.push(texture);
        }

        function updateMatrixText() {
            canvasElements.forEach(({ canvas, context, drops }, index) => {
                context.fillStyle = 'rgba(0, 0, 0, 0.05)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                context.fillStyle = '#00ff00';
                context.font = isMobile ? '10px Monospace' : '20px Monospace';
                const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()';
                const columns = canvas.width / (isMobile ? 10 : 20);
                for (let col = 0; col < columns; col++) {
                    const text = chars.charAt(Math.floor(Math.random() * chars.length));
                    const x = col * (isMobile ? 10 : 20);
                    const y = drops[col] * (isMobile ? 10 : 20);
                    context.fillText(text, x, y);
                    if (y > canvas.height && Math.random() > 0.975) drops[col] = 0;
                    drops[col]++;
                }
                canvasTextures[index].needsUpdate = true;
            });
        }

        // Three Wide-Screen LED Monitors
        const monitorFrameGeometry = new THREE.BoxGeometry(2.2, 1.2, 0.1);
        const monitors = [];
        for (let i = 0; i < 3; i++) {
            const x = -2.2 + i * 2.2;
            const monitorFrame = new THREE.Mesh(monitorFrameGeometry, itemMaterial);
            monitorFrame.position.set(x, 1.7, 1.5);
            monitorFrame.rotation.y = Math.PI;
            monitorFrame.position.z = 6 - (monitorFrame.position.z - 3);
            monitorFrame.position.x = -x;
            monitorFrame.castShadow = true;
            scene.add(monitorFrame);

            // Monitor screen with matrix text
            const monitorScreenGeometry = new THREE.PlaneGeometry(2.1, 1.1);
            const monitorScreen = new THREE.Mesh(monitorScreenGeometry, new THREE.MeshBasicMaterial({
                map: canvasTextures[i],
                emissive: 0x00ff00,
                emissiveIntensity: 0.8,
                side: THREE.DoubleSide
            }));
            monitorScreen.position.set(x, 1.7, 1.45);
            monitorScreen.rotation.y = Math.PI;
            monitorScreen.position.z = 6 - (monitorScreen.position.z - 3);
            monitorScreen.position.x = -x;
            scene.add(monitorScreen);

            // Monitor stand
            const monitorStandGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
            const monitorStand = new THREE.Mesh(monitorStandGeometry, itemMaterial);
            monitorStand.position.set(x, 1.25, 1.5);
            monitorStand.rotation.y = Math.PI;
            monitorStand.position.z = 6 - (monitorStand.position.z - 3);
            monitorStand.position.x = -x;
            scene.add(monitorStand);

            // Monitor neon edge
            const monitorEdgeGeometry = new THREE.EdgesGeometry(monitorFrameGeometry);
            const monitorEdge = new THREE.LineSegments(monitorEdgeGeometry, deskEdgeMaterial);
            monitorEdge.position.set(x, 1.7, 1.5);
            monitorEdge.rotation.y = Math.PI;
            monitorEdge.position.z = 6 - (monitorEdge.position.z - 3);
            monitorEdge.position.x = -x;
            scene.add(monitorEdge);

            monitors.push(monitorFrame);
        }

        // Keyboard - Matching monitors
        const keyboardGeometry = new THREE.BoxGeometry(2.2, 0.05, 0.6);
        const keyboard = new THREE.Mesh(keyboardGeometry, itemMaterial);
        keyboard.position.set(0, 0.825, 3.5);
        keyboard.rotation.y = Math.PI;
        keyboard.position.z = 6 - (keyboard.position.z - 3);
        keyboard.castShadow = true;
        scene.add(keyboard);

        // Glowing keys
        const keyGeometry = new THREE.BoxGeometry(0.08, 0.01, 0.08);
        const keyMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
        const keys = [];
        for (let i = -1; i <= 1; i += 0.12) {
            for (let j = -0.25; j <= 0.25; j += 0.12) {
                const key = new THREE.Mesh(keyGeometry, keyMaterial);
                key.position.set(i, 0.855, 3.5 + j);
                key.rotation.y = Math.PI;
                key.position.z = 6 - (key.position.z - 3);
                key.position.x = -i;
                scene.add(key);
                keys.push(key);
            }
        }

        // Keyboard neon edge
        const keyboardEdgeGeometry = new THREE.EdgesGeometry(keyboardGeometry);
        const keyboardEdge = new THREE.LineSegments(keyboardEdgeGeometry, deskEdgeMaterial);
        keyboardEdge.position.set(0, 0.825, 3.5);
        keyboardEdge.rotation.y = Math.PI;
        keyboardEdge.position.z = 6 - (keyboardEdge.position.z - 3);
        scene.add(keyboardEdge);

        // Ergonomic Mouse
        const mouseGeometry = new THREE.SphereGeometry(0.15, 32, 32);
        const mouse = new THREE.Mesh(mouseGeometry, itemMaterial);
        mouse.scale.set(1, 0.5, 1.5);
        mouse.position.set(1.3, 0.825, 3.6);
        mouse.rotation.y = Math.PI;
        mouse.position.z = 6 - (mouse.position.z - 3);
        mouse.position.x = -1.3;
        mouse.castShadow = true;
        scene.add(mouse);

        // Mouse details
        const mouseButtonGeometry = new THREE.BoxGeometry(0.06, 0.01, 0.08);
        const mouseButtonMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.5 });
        const leftButton = new THREE.Mesh(mouseButtonGeometry, mouseButtonMaterial);
        leftButton.position.set(1.3 - 0.05, 0.855, 3.65);
        leftButton.rotation.y = Math.PI;
        leftButton.position.z = 6 - (leftButton.position.z - 3);
        leftButton.position.x = -(1.3 - 0.05);
        scene.add(leftButton);
        const rightButton = new THREE.Mesh(mouseButtonGeometry, mouseButtonMaterial);
        rightButton.position.set(1.3 + 0.05, 0.855, 3.65);
        rightButton.rotation.y = Math.PI;
        rightButton.position.z = 6 - (rightButton.position.z - 3);
        rightButton.position.x = -(1.3 + 0.05);
        scene.add(rightButton);

        const scrollWheelGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.05, 16);
        const scrollWheel = new THREE.Mesh(scrollWheelGeometry, keyMaterial);
        scrollWheel.rotation.x = Math.PI / 2;
        scrollWheel.position.set(1.3, 0.855, 3.6);
        scrollWheel.rotation.y = Math.PI;
        scrollWheel.position.z = 6 - (scrollWheel.position.z - 3);
        scrollWheel.position.x = -1.3;
        scene.add(scrollWheel);

        // Mouse neon edge
        const mouseEdgeGeometry = new THREE.EdgesGeometry(mouseGeometry);
        const mouseEdge = new THREE.LineSegments(mouseEdgeGeometry, deskEdgeMaterial);
        mouseEdge.scale.set(1, 0.5, 1.5);
        mouseEdge.position.set(1.3, 0.825, 3.6);
        mouseEdge.rotation.y = Math.PI;
        mouseEdge.position.z = 6 - (mouseEdge.position.z - 3);
        mouseEdge.position.x = -1.3;
        scene.add(mouseEdge);

        // Speakers with White Cones
        const speakerGeometry = new THREE.BoxGeometry(0.6, 1, 0.4);
        const speaker1 = new THREE.Mesh(speakerGeometry, itemMaterial);
        speaker1.position.set(-3.5, 1.3, 3.5);
        speaker1.rotation.y = Math.PI;
        speaker1.position.z = 6 - (speaker1.position.z - 3);
        speaker1.position.x = 3.5;
        speaker1.castShadow = true;
        scene.add(speaker1);

        const speaker2 = new THREE.Mesh(speakerGeometry, itemMaterial);
        speaker2.position.set(3.5, 1.3, 3.5);
        speaker2.rotation.y = Math.PI;
        speaker2.position.z = 6 - (speaker2.position.z - 3);
        speaker2.position.x = -3.5;
        speaker2.castShadow = true;
        scene.add(speaker2);

        // White cones
        const coneGeometry = new THREE.ConeGeometry(0.15, 0.1, 32);
        const coneMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8, metalness: 0 });
        const cone1 = new THREE.Mesh(coneGeometry, coneMaterial);
        cone1.position.set(-3.5, 1.3, 3.25);
        cone1.rotation.x = Math.PI / 2;
        cone1.rotation.y = Math.PI;
        cone1.position.z = 6 - (cone1.position.z - 3);
        cone1.position.x = 3.5;
        scene.add(cone1);

        const cone2 = new THREE.Mesh(coneGeometry, coneMaterial);
        cone2.position.set(3.5, 1.3, 3.25);
        cone2.rotation.x = Math.PI / 2;
        cone2.rotation.y = Math.PI;
        cone2.position.z = 6 - (cone2.position.z - 3);
        cone2.position.x = -3.5;
        scene.add(cone2);

        // Speaker neon edges
        const speakerEdgeGeometry = new THREE.EdgesGeometry(speakerGeometry);
        const speakerEdge1 = new THREE.LineSegments(speakerEdgeGeometry, deskEdgeMaterial);
        speakerEdge1.position.set(-3.5, 1.3, 3.5);
        speakerEdge1.rotation.y = Math.PI;
        speakerEdge1.position.z = 6 - (speakerEdge1.position.z - 3);
        speakerEdge1.position.x = 3.5;
        scene.add(speakerEdge1);

        const speakerEdge2 = new THREE.LineSegments(speakerEdgeGeometry, deskEdgeMaterial);
        speakerEdge2.position.set(3.5, 1.3, 3.5);
        speakerEdge2.rotation.y = Math.PI;
        speakerEdge2.position.z = 6 - (speakerEdge2.position.z - 3);
        speakerEdge2.position.x = -3.5;
        scene.add(speakerEdge2);

        // EQ Console - Matching monitors
        const eqConsoleGeometry = new THREE.BoxGeometry(1.8, 0.1, 1);
        const eqConsole = new THREE.Mesh(eqConsoleGeometry, itemMaterial);
        eqConsole.position.set(-2.2, 0.85, 3.5);
        eqConsole.rotation.y = Math.PI;
        eqConsole.position.z = 6 - (eqConsole.position.z - 3);
        eqConsole.position.x = 2.2;
        eqConsole.castShadow = true;
        scene.add(eqConsole);

        // EQ Console sliders and lights
        const sliderGeometry = new THREE.BoxGeometry(0.05, 0.1, 0.2);
        const sliderMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.5 });
        const sliders = [];
        for (let i = 0; i < 6; i++) {
            const x = -2.6 + i * 0.2;
            const slider = new THREE.Mesh(sliderGeometry, sliderMaterial);
            slider.position.set(x, 0.9 + Math.sin(i) * 0.02, 3.6);
            slider.rotation.y = Math.PI;
            slider.position.z = 6 - (slider.position.z - 3);
            slider.position.x = -x;
            scene.add(slider);
            sliders.push(slider);
        }

        const eqLightGeometry = new THREE.SphereGeometry(0.02, 16, 16);
        const eqLightMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
        const eqLights = [];
        for (let i = 0; i < 6; i++) {
            const x = -2.6 + i * 0.2;
            const eqLight = new THREE.Mesh(eqLightGeometry, eqLightMaterial);
            eqLight.position.set(x, 0.9, 3.5);
            eqLight.rotation.y = Math.PI;
            eqLight.position.z = 6 - (eqLight.position.z - 3);
            eqLight.position.x = -x;
            scene.add(eqLight);
            eqLights.push(eqLight);
        }

        // EQ Console neon edge
        const eqEdgeGeometry = new THREE.EdgesGeometry(eqConsoleGeometry);
        const eqEdge = new THREE.LineSegments(eqEdgeGeometry, deskEdgeMaterial);
        eqEdge.position.set(-2.2, 0.85, 3.5);
        eqEdge.rotation.y = Math.PI;
        eqEdge.position.z = 6 - (eqEdge.position.z - 3);
        eqEdge.position.x = 2.2;
        scene.add(eqEdge);

        // Server Rack
        const serverRackGeometry = new THREE.BoxGeometry(2, 0.8, 1);
        const serverRack = new THREE.Mesh(serverRackGeometry, itemMaterial);
        serverRack.position.set(2.2, 0.4, 3);
        serverRack.rotation.y = Math.PI;
        serverRack.position.z = 6 - (serverRack.position.z - 3);
        serverRack.position.x = -2.2;
        serverRack.castShadow = true;
        scene.add(serverRack);

        // Server rack levels
        const levelGeometry = new THREE.BoxGeometry(0.3, 0.05, 0.05);
        const levelMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
        const levels = [];
        for (let i = 0; i < 4; i++) {
            const level = new THREE.Mesh(levelGeometry, levelMaterial);
            level.position.set(2.2, 0.2 + i * 0.1, 3.5);
            level.rotation.y = Math.PI;
            level.position.z = 6 - (level.position.z - 3);
            level.position.x = -2.2;
            scene.add(level);
            levels.push(level);
        }

        // Server rack blinkers
        const blinkerGeometry = new THREE.SphereGeometry(0.03, 16, 16);
        const blinkerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
        const blinkers = [];
        for (let i = 0; i < 5; i++) {
            const x = 1.7 + i * 0.2;
            const blinker = new THREE.Mesh(blinkerGeometry, blinkerMaterial);
            blinker.position.set(x, 0.6, 3.5);
            blinker.rotation.y = Math.PI;
            blinker.position.z = 6 - (blinker.position.z - 3);
            blinker.position.x = -x;
            scene.add(blinker);
            blinkers.push(blinker);
        }

        // Server rack neon edge
        const serverEdgeGeometry = new THREE.EdgesGeometry(serverRackGeometry);
        const serverEdge = new THREE.LineSegments(serverEdgeGeometry, deskEdgeMaterial);
        serverEdge.position.set(2.2, 0.4, 3);
        serverEdge.rotation.y = Math.PI;
        serverEdge.position.z = 6 - (serverEdge.position.z - 3);
        serverEdge.position.x = -2.2;
        scene.add(serverEdge);

        // Sofa with Neon Green Base Glow
        const sofaMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.4,
            metalness: 0.3
        });
        const sofaBaseGeometry = new THREE.BoxGeometry(4.5, 0.5, 1);
        const sofaBackGeometry = new THREE.BoxGeometry(4.5, 1, 0.3);
        const sofaArmGeometry = new THREE.BoxGeometry(0.5, 0.5, 1);
        const sofaCushionGeometry = new THREE.BoxGeometry(1.4, 0.2, 0.8);

        const sofaBase = new THREE.Mesh(sofaBaseGeometry, sofaMaterial);
        sofaBase.position.set(0, 0.25, -4.2);
        sofaBase.castShadow = true;
        scene.add(sofaBase);

        const sofaGlowMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 0.5
        });
        const sofaGlowGeometry = new THREE.BoxGeometry(4.6, 0.05, 1.1);
        const sofaGlow = new THREE.Mesh(sofaGlowGeometry, sofaGlowMaterial);
        sofaGlow.position.set(0, 0.025, -4.2);
        scene.add(sofaGlow);

        const sofaBack = new THREE.Mesh(sofaBackGeometry, sofaMaterial);
        sofaBack.position.set(0, 0.75, -4.45);
        scene.add(sofaBack);

        const sofaArmLeft = new THREE.Mesh(sofaArmGeometry, sofaMaterial);
        sofaArmLeft.position.set(-2.25, 0.5, -4.2);
        scene.add(sofaArmLeft);

        const sofaArmRight = new THREE.Mesh(sofaArmGeometry, sofaMaterial);
        sofaArmRight.position.set(2.25, 0.5, -4.2);
        scene.add(sofaArmRight);

        for (let x = -1.5; x <= 1.5; x += 1.5) {
            const cushion = new THREE.Mesh(sofaCushionGeometry, sofaMaterial);
            cushion.position.set(x, 0.45, -4.2);
            scene.add(cushion);
        }

        // Neon sign
        const signCanvas = document.createElement('canvas');
        signCanvas.width = isMobile ? 512 : 1024;
        signCanvas.height = isMobile ? 128 : 256;
        const signContext = signCanvas.getContext('2d');
        signContext.fillStyle = '#000000';
        signContext.fillRect(0, 0, signCanvas.width, signCanvas.height);
        signContext.font = isMobile ? '100px Arial' : '200px Arial';
        signContext.fillStyle = '#00ff00';
        signContext.textAlign = 'center';
        signContext.textBaseline = 'middle';
        signContext.fillText('webXOS', signCanvas.width / 2, signCanvas.height / 2);
        const signTexture = new THREE.CanvasTexture(signCanvas);

        const neonSignGeometry = new THREE.PlaneGeometry(3, 0.75);
        const neonSignMaterial = new THREE.MeshBasicMaterial({
            map: signTexture,
            transparent: true,
            emissive: 0x00ff00,
            emissiveIntensity: 2
        });
        const neonSign = new THREE.Mesh(neonSignGeometry, neonSignMaterial);
        neonSign.position.set(0, 3, -4.9);
        scene.add(neonSign);

        const signGlowLight = new THREE.PointLight(0x00ff00, 2, 5);
        signGlowLight.position.set(0, 3, -4.8);
        scene.add(signGlowLight);

        // Page navigation and camera positions
        const pages = {
            about: {
                cameraPos: new THREE.Vector3(4.5, 2.2, -1),
                lookAt: new THREE.Vector3(0, 2, -4.9),
                text: "About: Learn more about webXOS Studio\nOur mission and vision.",
                centerText: "About webXOS Studio"
            },
            tools: {
                cameraPos: new THREE.Vector3(4, 2, -0.5),
                lookAt: new THREE.Vector3(0, 1, 3),
                text: "Tools: Explore our suite of development tools\nDesigned for efficiency.",
                centerText: "Our Tools"
            },
            aiAgents: {
                cameraPos: new THREE.Vector3(4.5, 6, 4),
                lookAt: new THREE.Vector3(0, 1, 0),
                text: "AI Agents: Discover our intelligent agents\nPowering the future.",
                centerText: "AI Agents"
            },
            games: {
                cameraPos: new THREE.Vector3(-4, 2, -0.5),
                lookAt: new THREE.Vector3(0, 1, 3),
                text: "Games: Dive into our gaming experiences\nFun and immersive.",
                centerText: "Games by webXOS"
            },
            copyright: {
                cameraPos: new THREE.Vector3(2, 2.5, -2),
                lookAt: new THREE.Vector3(0, 2, -4.9),
                text: "Copyright: View our licensing information\nProtecting our work.",
                centerText: "Copyright Information"
            }
        };

        let currentPage = 'about';

        function navigateTo(page) {
            currentPage = page;
            const pageData = pages[page];
            camera.position.copy(pageData.cameraPos);
            camera.lookAt(pageData.lookAt);
            document.getElementById('textOverlay').innerText = pageData.text;
            document.getElementById('centerOverlay').innerHTML = pageData.centerText;
            toggleMenu();
        }

        // Initial page load
        navigateTo('about');

        // Animation loop
        let time = 0;
        function animate() {
            time += 0.05;

            // Update matrix text (optimized for mobile)
            if (!isMobile || time % 2 < 1) updateMatrixText();

            // Animate neural ceiling (reduced for mobile)
            if (!isMobile || time % 3 < 1) {
                neuralLinesGeometry.attributes.position.array.forEach((_, i) => {
                    if (i % 3 === 1) {
                        neuralLinesGeometry.attributes.position.array[i] = 4.8 + Math.sin(time + i) * 0.05;
                    }
                });
                neuralLinesGeometry.attributes.position.needsUpdate = true;
            }

            // Animate neon edges and lights
            deskEdge.material.opacity = 0.3 + 0.1 * Math.sin(time * 1.5);
            keyboardEdge.material.opacity = 0.3 + 0.1 * Math.sin(time * 1.5);
            mouseEdge.material.opacity = 0.3 + 0.1 * Math.sin(time * 1.5);
            speakerEdge1.material.opacity = 0.3 + 0.1 * Math.sin(time * 1.5);
            speakerEdge2.material.opacity = 0.3 + 0.1 * Math.sin(time * 1.5);
            eqEdge.material.opacity = 0.3 + 0.1 * Math.sin(time * 1.5);
            serverEdge.material.opacity = 0.3 + 0.1 * Math.sin(time * 1.5);
            sofaGlow.material.emissiveIntensity = 0.5 + 0.2 * Math.sin(time * 1.5);
            monitors.forEach((_, i) => {
                monitors[i].children[0].material.opacity = 0.3 + 0.1 * Math.sin(time * 1.5);
            });
            blinkers.forEach((blinker, index) => {
                blinker.material.opacity = 0.3 + 0.2 * Math.sin(time + index);
            });
            eqLights.forEach((light, index) => {
                light.material.opacity = 0.3 + 0.2 * Math.sin(time + index * 0.5);
            });
            levels.forEach((level, index) => {
                level.scale.y = 1 + Math.sin(time + index) * 0.5;
            });

            renderer.render(scene, camera);
        }

        // Responsive handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
        });

        // Menu toggle
        function toggleMenu() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('open');
        }

        // Prevent pinch-to-zoom on mobile
        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('touchmove', e => {
            if (e.touches.length > 1) e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
